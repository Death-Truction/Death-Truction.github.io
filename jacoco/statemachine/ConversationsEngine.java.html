<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConversationsEngine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">conversations-engine</a> &gt; <a href="index.source.html" class="el_package">statemachine</a> &gt; <span class="el_source">ConversationsEngine.java</span></div><h1>ConversationsEngine.java</h1><pre class="source lang-java linenums">package statemachine;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Timer;
import java.util.TimerTask;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import org.json.JSONObject;

import interfaces.INLPAnswer;
import interfaces.INLPComponent;
import interfaces.ISkill;
import interfaces.ISkillAnswer;

/**
 * The ConversationsEngineStateMachine is a ChatBot-Framework to TODO: finish
 * this
 * 
 * @author Marcel Engelmann
 *
 */
public class ConversationsEngine {

	private static final int DEFAULTTIMEOUTVALUE = 300;
	private static final String EMPTYCONTEXTOBJECT = &quot;{}&quot;;

	private State currentState;
	private SkillStateMachine currentSkillStateMachine;
	private SkillStateMachine lastUsedSkillStateMachine;
	private PendingQuestions pendingSkillQuestions;
	private JSONObject contextObject;
	private Timer timer;
	private String lastIntent;
	private INLPComponent nlpComponent;
	private List&lt;String&gt; possibleSkillsForChooseSkillQuestion;
	private List&lt;SkillStateMachine&gt; allSkillStateMachines;
	private Deque&lt;String&gt; pendingIntents;
	private boolean wasLastQuestionChooseSkill;
	private boolean wasLastQuestionSkillQuestion;
	private boolean wasLastQuestionAbortQuestion;
	private boolean wasLastQuestionReturnToPreviousSkill;
	private boolean closed;
	private int timeoutInSeconds;

	/**
	 * Creates a new {@link ConversationsEngine} object
	 * 
	 * @param nlpComponent      the NLPComponent that handles the user input
	 * @param timeoutInSeconds  the number of seconds after which the
	 *                          {@link ConversationsEngine} will transition into the
	 *                          sleepState. The timer refreshes after each
	 *                          interaction.
	 * @param jsonContextObject the contextObject as JSON-String to start the
	 *                          {@link ConversationsEngine} with
	 */
	public ConversationsEngine(INLPComponent nlpComponent, int timeoutInSeconds, String jsonContextObject)
<span class="fc" id="L66">			throws IllegalArgumentException {</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">		if (nlpComponent == null) {</span>
<span class="fc" id="L68">			Logging.error(&quot;INLPComponent is null&quot;);</span>
<span class="fc" id="L69">			throw new IllegalArgumentException(&quot;INLPComponent is null&quot;);</span>
		}

<span class="fc bfc" id="L72" title="All 2 branches covered.">		if (timeoutInSeconds &lt;= 0) {</span>
<span class="fc" id="L73">			Logging.error(&quot;Timeout value must be greater than 0&quot;);</span>
<span class="fc" id="L74">			throw new IllegalArgumentException(&quot;Timeout value must be greater than 0&quot;);</span>
		}
<span class="fc" id="L76">		State defaultState = new State(&quot;defaultState&quot;);</span>
<span class="fc" id="L77">		State sleepState = new State(&quot;sleepState&quot;);</span>
<span class="fc" id="L78">		defaultState.addTransition(new Transition(sleepState, &quot;SLEEP&quot;));</span>
<span class="fc" id="L79">		sleepState.addTransition(new Transition(defaultState, &quot;WAKEUP&quot;));</span>
<span class="fc" id="L80">		this.currentState = defaultState;</span>
<span class="fc" id="L81">		this.nlpComponent = nlpComponent;</span>
<span class="fc" id="L82">		this.contextObject = new JSONObject(jsonContextObject);</span>
<span class="fc" id="L83">		this.allSkillStateMachines = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L84">		this.possibleSkillsForChooseSkillQuestion = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L85">		this.pendingSkillQuestions = new PendingQuestions();</span>
<span class="fc" id="L86">		this.pendingIntents = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L87">		this.lastIntent = &quot;&quot;;</span>
<span class="fc" id="L88">		this.wasLastQuestionChooseSkill = false;</span>
<span class="fc" id="L89">		this.wasLastQuestionSkillQuestion = false;</span>
<span class="fc" id="L90">		this.wasLastQuestionAbortQuestion = false;</span>
<span class="fc" id="L91">		this.wasLastQuestionReturnToPreviousSkill = false;</span>
<span class="fc" id="L92">		this.closed = false;</span>
<span class="fc" id="L93">		this.timeoutInSeconds = timeoutInSeconds;</span>
<span class="fc" id="L94">		I18n.setLanguage(new Locale(&quot;de&quot;, &quot;DE&quot;));</span>
		// the list of intents the ConversationsEngine uses itself (as trigger words)
<span class="fc" id="L96">		List&lt;String&gt; triggerIntents = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L97">		triggerIntents.add(&quot;abort&quot;);</span>
<span class="fc" id="L98">		triggerIntents.add(&quot;last&quot;);</span>
<span class="fc" id="L99">		triggerIntents.add(&quot;all&quot;);</span>
<span class="fc" id="L100">		triggerIntents.add(&quot;yes&quot;);</span>
<span class="fc" id="L101">		triggerIntents.add(&quot;no&quot;);</span>
<span class="fc" id="L102">		this.nlpComponent.addUsedIntents(triggerIntents);</span>
<span class="fc" id="L103">		this.timer = new Timer();</span>
<span class="fc" id="L104">		scheduleNewTimeoutTask();</span>
<span class="fc" id="L105">	}</span>

	/**
	 * Creates a new {@link ConversationsEngine} object with a default timeout of
	 * {@value ConversationsEngine#DEFAULTTIMEOUTVALUE} seconds and an empty context
	 * object
	 * 
	 * @param nlpComponent the NLPComponent that handles the user input
	 */
	public ConversationsEngine(INLPComponent nlpComponent) {
<span class="fc" id="L115">		this(nlpComponent, DEFAULTTIMEOUTVALUE, EMPTYCONTEXTOBJECT);</span>
<span class="fc" id="L116">	}</span>

	/**
	 * Creates a new {@link ConversationsEngine} object with an empty context object
	 * 
	 * @param nlpComponent     the NLPComponent that handles the user input
	 * @param timeoutInSeconds the number of seconds after which the
	 *                         {@link ConversationsEngine} will transition into the
	 *                         sleepState. The timer refreshes after each
	 *                         interaction.
	 */
	public ConversationsEngine(INLPComponent nlpComponent, int timeoutInSeconds) {
<span class="fc" id="L128">		this(nlpComponent, timeoutInSeconds, EMPTYCONTEXTOBJECT);</span>
<span class="fc" id="L129">	}</span>

	/**
	 * Creates a new {@link ConversationsEngine} object with a default timeout of
	 * {@value ConversationsEngine#DEFAULTTIMEOUTVALUE} seconds
	 * 
	 * @param nlpComponent      the NLPComponent that handles the user input
	 * @param jsonContextObject the contextObject as JSON-String to start the
	 *                          {@link ConversationsEngine} with
	 */
	public ConversationsEngine(INLPComponent nlpComponent, String jsonContextObject) {
<span class="fc" id="L140">		this(nlpComponent, DEFAULTTIMEOUTVALUE, jsonContextObject);</span>
<span class="fc" id="L141">	}</span>

	/**
	 * Returns the state machine's current state
	 * 
	 * @return the state machine's current state
	 */
	public String getState() {
<span class="fc bfc" id="L149" title="All 2 branches covered.">		if (this.closed) {</span>
<span class="fc" id="L150">			logIllegalAccess();</span>
<span class="fc" id="L151">			return &quot;&quot;;</span>
		}
<span class="fc bfc" id="L153" title="All 2 branches covered.">		if (this.currentSkillStateMachine != null)</span>
<span class="fc" id="L154">			return this.currentSkillStateMachine.getCurrentState().getName();</span>
<span class="fc" id="L155">		return this.currentState.getName();</span>
	}

	/**
	 * Add a new Skill to the {@link ConversationsEngine}
	 * 
	 * @param skill            the skill to add to the {@link ConversationsEngine}
	 * @param jsonStateMachine the skill's state machine in JSON-Format. For the
	 *                         JSON-Schema please check out the &lt;a href=
	 *                         &quot;file:../../resources/SkillStateMachine_Schema.json&quot;&gt;Schema.json&lt;/a&gt;
	 *                         file
	 */
	public void addSkill(ISkill skill, String jsonStateMachine) {
<span class="fc bfc" id="L168" title="All 2 branches covered.">		if (this.closed) {</span>
<span class="fc" id="L169">			logIllegalAccess();</span>
<span class="fc" id="L170">			return;</span>
		}
<span class="fc bfc" id="L172" title="All 2 branches covered.">		if (skill == null) {</span>
<span class="fc" id="L173">			Logging.error(&quot;The skill to add to the ConversationsEngine is null&quot;);</span>
<span class="fc" id="L174">			return;</span>
		}

<span class="fc bfc" id="L177" title="All 2 branches covered.">		if (jsonStateMachine.isBlank()) {</span>
<span class="fc" id="L178">			Logging.error(&quot;The JSON-String for the skill to add to the ConversationsEngine is blank&quot;, skill);</span>
<span class="fc" id="L179">			return;</span>
		}
<span class="fc" id="L181">		SkillStateMachine newSkillStateMachine = GenerateSkillStateMachine.fromJson(skill, jsonStateMachine,</span>
				nlpComponent);
<span class="fc bfc" id="L183" title="All 2 branches covered.">		if (newSkillStateMachine == null) {</span>
<span class="fc" id="L184">			Logging.error(&quot;Could not add the skill from the jsonString {}&quot;, jsonStateMachine);</span>
<span class="fc" id="L185">			return;</span>
		}

<span class="fc bfc" id="L188" title="All 2 branches covered.">		if (allSkillStateMachines.stream().anyMatch(</span>
<span class="fc" id="L189">				skillStateMachine -&gt; skillStateMachine.getName().equalsIgnoreCase(newSkillStateMachine.getName()))) {</span>
<span class="fc" id="L190">			Logging.error(&quot;The skill {} already exists&quot;, newSkillStateMachine.getName());</span>
<span class="fc" id="L191">			return;</span>
		}

<span class="fc" id="L194">		allSkillStateMachines.add(newSkillStateMachine);</span>
<span class="fc" id="L195">	}</span>

	/**
	 * Shuts this ConversationsEngine object down and returns the current context
	 * object to the given operation
	 * 
	 * @param operation the operation to call, with the context object passed as
	 *                  parameter, after shutting down.
	 */
	public void shutdown(Consumer&lt;StringBuffer&gt; operation) {
<span class="fc bfc" id="L205" title="All 2 branches covered.">		if (this.closed) {</span>
<span class="fc" id="L206">			logIllegalAccess();</span>
<span class="fc" id="L207">			return;</span>
		}
<span class="fc" id="L209">		Logging.debug(&quot;Shutting down the ConversationsEngine {}&quot;, this);</span>
<span class="fc" id="L210">		this.timer.cancel();</span>
<span class="fc" id="L211">		this.closed = true;</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">		if (operation == null) {</span>
<span class="fc" id="L213">			Logging.warn(&quot;The consumer passed to the shutdown function was null&quot;);</span>
<span class="fc" id="L214">			return;</span>
		}
<span class="fc" id="L216">		StringBuffer buffer = new StringBuffer();</span>
<span class="fc" id="L217">		buffer.append(this.contextObject);</span>
<span class="fc" id="L218">		this.contextObject = new JSONObject();</span>
<span class="fc" id="L219">		operation.accept(buffer);</span>
<span class="fc" id="L220">	}</span>

	/**
	 * Processes a new input and returns a {@link List} of answers
	 * 
	 * @param input the input to process
	 * @return a {@link List} of answers
	 */
	public List&lt;String&gt; userInput(String input) {
<span class="fc bfc" id="L229" title="All 2 branches covered.">		if (this.closed) {</span>
<span class="fc" id="L230">			logIllegalAccess();</span>
<span class="fc" id="L231">			return new ArrayList&lt;&gt;();</span>
		}
<span class="fc bfc" id="L233" title="All 4 branches covered.">		if (input == null || input.isBlank()) {</span>
<span class="fc" id="L234">			Logging.warn(&quot;The user input was null or blank&quot;);</span>
<span class="fc" id="L235">			UserOutput.addDefaultErrorMessage();</span>
<span class="fc" id="L236">			return UserOutput.popNextOutput();</span>
		}
<span class="fc" id="L238">		Logging.userInput(input);</span>
<span class="fc" id="L239">		leaveSleepState();</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">		if (this.wasLastQuestionSkillQuestion) {</span>
<span class="fc" id="L241">			processSkillQuestion(input);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">		} else if (this.wasLastQuestionChooseSkill) {</span>
<span class="fc" id="L243">			processChooseSkillQuestion(input);</span>
		} else {
<span class="fc" id="L245">			processNormalRequest(input);</span>
		}

<span class="fc" id="L248">		return UserOutput.popNextOutput();</span>
	}

	/**
	 * Processes the input normally as a new input not relating to a question asked
	 * previously
	 * 
	 * @param input the user input
	 */
	private void processNormalRequest(String input) {
<span class="fc" id="L258">		processINLPAnswer(this.nlpComponent.understandInput(input, this.contextObject));</span>

<span class="fc" id="L260">	}</span>

	/**
	 * Processes the input normally as a new input not relating to a question asked
	 * previously
	 * 
	 * @param processedInput the {@link INLPAnswer} of a {@link INLPComponent}
	 */
	private void processINLPAnswer(INLPAnswer processedInput) {
<span class="fc bfc" id="L269" title="All 2 branches covered.">		if (processedInput == null) {</span>
<span class="fc" id="L270">			Logging.error(&quot;NLP Component's returned INLPAnswer is null&quot;);</span>
<span class="fc" id="L271">			UserOutput.addDefaultErrorMessage();</span>
<span class="fc" id="L272">			return;</span>
		}
<span class="fc" id="L274">		List&lt;String&gt; intents = processedInput.getIntents();</span>
<span class="fc" id="L275">		Locale foundLanguage = processedInput.getInputLanguage();</span>
<span class="fc" id="L276">		boolean addedEntities = processedInput.hasAddedEntities();</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">		if (foundLanguage == null) {</span>
<span class="fc" id="L278">			Logging.error(&quot;NLPComponent did not return a language&quot;);</span>
		} else {
<span class="fc" id="L280">			I18n.setLanguage(foundLanguage);</span>
		}
		// If the NLPAnswer has no result -&gt; treat it as bad input
<span class="fc bfc" id="L283" title="All 6 branches covered.">		if (!addedEntities &amp;&amp; (intents == null || intents.isEmpty())) {</span>
<span class="fc" id="L284">			UserOutput.addDefaultErrorMessage();</span>
<span class="fc" id="L285">			return;</span>
		}
<span class="pc bpc" id="L287" title="1 of 4 branches missed.">		if (intents != null &amp;&amp; !intents.isEmpty()) {</span>
			// keep the correct input order for the stack/dequeue
<span class="fc" id="L289">			Collections.reverse(intents);</span>
<span class="fc" id="L290">			this.pendingIntents.addAll(intents);</span>
<span class="fc bfc" id="L291" title="All 4 branches covered.">			if (this.wasLastQuestionAbortQuestion || this.wasLastQuestionReturnToPreviousSkill) {</span>
<span class="fc" id="L292">				processSpecialQuestion();</span>
<span class="fc" id="L293">				return;</span>
			}
<span class="fc bfc" id="L295" title="All 2 branches covered.">			if (intents.get(0).equalsIgnoreCase(&quot;abort&quot;)) {</span>
<span class="fc" id="L296">				this.pendingIntents.removeLast();</span>
<span class="fc" id="L297">				abortRequested();</span>
<span class="fc" id="L298">				return;</span>
			}
		}
<span class="fc" id="L301">		evaluateNextAction();</span>
<span class="fc" id="L302">	}</span>

	private void processSpecialQuestion() {
<span class="fc bfc" id="L305" title="All 2 branches covered.">		if (this.wasLastQuestionAbortQuestion) {</span>
<span class="fc" id="L306">			this.wasLastQuestionAbortQuestion = false;</span>
<span class="fc" id="L307">			processAbortQuestion();</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">		} else if (wasLastQuestionReturnToPreviousSkill) {</span>
<span class="fc" id="L309">			this.wasLastQuestionReturnToPreviousSkill = false;</span>
<span class="fc" id="L310">			processReturnToPreviousSkillQuestion();</span>
		}

<span class="fc" id="L313">	}</span>

	/**
	 * Tries to process the intent as an answer to an abort question &lt;br&gt;
	 * &lt;br&gt;
	 * If the answer was to abort the last skill, then the
	 * {@link #currentSkillStateMachine} will be
	 * {@link #resetCurrentSkillStateMachine reset} and the next action will be
	 * {@link #evaluateNextAction() evaluated} &lt;br&gt;
	 * 
	 * If the answer was to abort all skills, then the pipeline will be
	 * {@link #clearPipeline cleared} &lt;br&gt;
	 * If the abort question was not answered, the input will be processed
	 * {@link #checkNormalRequest}
	 * 
	 * @param intent the intent to process
	 */
	private void processAbortQuestion() {
<span class="fc" id="L331">		String intent = this.pendingIntents.peekLast();</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">		if (intent.equalsIgnoreCase(&quot;last&quot;)) {</span>
<span class="fc" id="L333">			this.pendingIntents.removeLast();</span>
<span class="fc" id="L334">			resetCurrentSkillStateMachine(false);</span>
<span class="fc" id="L335">			UserOutput.addOutputMessageFromLocalizationKey(&quot;BackToSkill&quot;, this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L336">			evaluateNextAction();</span>
<span class="fc" id="L337">			return;</span>
		}
<span class="fc bfc" id="L339" title="All 2 branches covered.">		if (intent.equalsIgnoreCase(&quot;all&quot;)) {</span>
<span class="fc" id="L340">			this.pendingIntents.removeLast();</span>
<span class="fc" id="L341">			this.clearPipeline();</span>
<span class="fc" id="L342">			return;</span>
		}
<span class="fc" id="L344">		askAbortQuestion();</span>
<span class="fc" id="L345">	}</span>

	/**
	 * Tries to process the intent as an answer to the &quot;Return to the previous
	 * skill&quot; question&lt;br&gt;
	 * &lt;br&gt;
	 * 
	 * If the answer was to return to the next skill, then the
	 * {@link #currentSkillStateMachine} will be
	 * {@link #resetCurrentSkillStateMachine(boolean) reset}&lt;br&gt;
	 * 
	 * If the answer was to abort all skills, then the pipeline will be
	 * {@link #clearPipeline() cleared}&lt;br&gt;
	 * 
	 * If the abort question was not answered, the input will be processed
	 * {@link #processNormalRequest normally}
	 * 
	 * @param intent the intent to process
	 * 
	 */
	private void processReturnToPreviousSkillQuestion() {
<span class="fc" id="L366">		String intent = this.pendingIntents.peekLast();</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">		if (intent.equalsIgnoreCase(&quot;Yes&quot;)) {</span>
<span class="fc" id="L368">			this.pendingIntents.removeLast();</span>
<span class="fc" id="L369">			UserOutput.addOutputMessageFromLocalizationKey(&quot;BackToSkill&quot;, this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L370">			evaluateNextAction();</span>
<span class="fc" id="L371">			return;</span>
		}
<span class="fc bfc" id="L373" title="All 2 branches covered.">		if (intent.equalsIgnoreCase(&quot;No&quot;)) {</span>
<span class="fc" id="L374">			this.pendingIntents.removeLast();</span>
<span class="fc" id="L375">			resetCurrentSkillStateMachine(true);</span>
<span class="fc" id="L376">			return;</span>
		}
<span class="fc" id="L378">		askContinueLastSkill();</span>
<span class="fc" id="L379">	}</span>

	/**
	 * Tries to process the input as an answer to a skill question. If the question
	 * was not answered, the corresponding skill will have to ask the question again
	 * 
	 * @param input the input to process
	 */
	private void processSkillQuestion(String input) {
<span class="fc" id="L388">		this.wasLastQuestionSkillQuestion = false;</span>
<span class="fc" id="L389">		String entityName = &quot;&quot;;</span>
		INLPAnswer processedInput;
<span class="fc" id="L391">		entityName = this.pendingSkillQuestions.getTopEntity(this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L392">		processedInput = this.nlpComponent.understandInput(input, entityName, this.contextObject);</span>
		// Remove last asked question. If the question was not answered, then the
		// corresponding skill will have to ask the same question again
<span class="fc" id="L395">		this.pendingSkillQuestions.removeTopQuestionAndEntity(this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L396">		processINLPAnswer(processedInput);</span>
<span class="fc" id="L397">	}</span>

	/**
	 * Tries to process the input as an answer to a question to choose a skill&lt;br&gt;
	 * &lt;br&gt;
	 * If the input equals to a fitting skill, that skill will be executed and the
	 * last intent will be processed Otherwise the input will be processed as a
	 * {@link #processNormalRequest normal request}
	 * 
	 * @param input the input to process
	 */
	private void processChooseSkillQuestion(String input) {
		// match input to possible skills to choose from
<span class="fc" id="L410">		String nextSkill = this.possibleSkillsForChooseSkillQuestion.stream().filter(input::equalsIgnoreCase)</span>
<span class="fc" id="L411">				.findFirst().orElse(&quot;&quot;);</span>

<span class="fc bfc" id="L413" title="All 2 branches covered.">		if (nextSkill.isEmpty()) {</span>
<span class="fc" id="L414">			Logging.debug(</span>
					&quot;The question to choose a skill was not answered!\nPossible skills are: {}\nUser input is: {}&quot;,
					this.possibleSkillsForChooseSkillQuestion, input);
<span class="fc" id="L417">			askChooseSkillQuestion();</span>
		} else {
<span class="fc" id="L419">			this.wasLastQuestionChooseSkill = false;</span>
<span class="fc" id="L420">			final String skillName = nextSkill;</span>
<span class="fc" id="L421">			leaveCurrentSkillStateMachine();</span>
<span class="fc" id="L422">			this.currentSkillStateMachine = this.allSkillStateMachines.stream()</span>
<span class="fc" id="L423">					.filter(skill -&gt; skill.getName().equals(skillName)).findFirst().orElse(null);</span>
<span class="fc" id="L424">			evaluateNextAction();</span>
		}
<span class="fc" id="L426">	}</span>

	/**
	 * Processes the next {@link #pendingIntents intent}
	 *
	 */
	private void processNextIntent() {
<span class="fc" id="L433">		String intent = pendingIntents.peekLast();</span>
<span class="fc" id="L434">		Logging.debug(&quot;Processing the intent '{}'&quot;, intent);</span>
<span class="fc" id="L435">		this.lastIntent = intent;</span>
<span class="fc" id="L436">		SkillStateMachine nextSkillStateMachine = getNextSkillStateMachine(intent);</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">		if (nextSkillStateMachine == null) {</span>
<span class="fc" id="L438">			return;</span>
		}
<span class="fc" id="L440">		this.currentSkillStateMachine = nextSkillStateMachine;</span>

<span class="fc" id="L442">		ISkillAnswer answer = this.currentSkillStateMachine.execute(intent, this.contextObject);</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">		if (answer == null) {</span>
<span class="fc" id="L444">			UserOutput.addDefaultErrorMessage();</span>
<span class="fc" id="L445">			return;</span>
		}

<span class="fc" id="L448">		this.processSkillAnswer(answer);</span>
<span class="fc bfc" id="L449" title="All 4 branches covered.">		if (hasSkillStateMachineEnded() &amp;&amp; this.currentSkillStateMachine != null) {</span>
<span class="fc" id="L450">			wasLastQuestionReturnToPreviousSkill = true;</span>
<span class="fc" id="L451">			askContinueLastSkill();</span>
<span class="fc" id="L452">			return;</span>
		}
<span class="fc" id="L454">		evaluateNextAction();</span>
<span class="fc" id="L455">	}</span>

	/**
	 * Processes a {@link ISkillAnswer} of a skill
	 * 
	 * @param skillAnswer the answer of a skill
	 */
	private void processSkillAnswer(ISkillAnswer skillAnswer) {
<span class="fc" id="L463">		boolean answerIsEmpty = true;</span>
<span class="fc bfc" id="L464" title="All 4 branches covered.">		if (skillAnswer.answers() != null &amp;&amp; !skillAnswer.answers().isEmpty()) {</span>
<span class="fc" id="L465">			UserOutput.addOutputMessages(skillAnswer.answers());</span>
<span class="fc" id="L466">			answerIsEmpty = false;</span>
		}
<span class="fc bfc" id="L468" title="All 2 branches covered.">		if (skillAnswer.skipUserOutput()) {</span>
<span class="fc" id="L469">			Logging.debug(&quot;Skipping user Output&quot;);</span>
<span class="fc" id="L470">			return;</span>
		}
<span class="fc bfc" id="L472" title="All 2 branches covered.">		if (skillAnswer.requiredQuestionsToBeAnswered() == null</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">				|| skillAnswer.requiredQuestionsToBeAnswered().size() == 0) {</span>
			// remove last processed intent
<span class="fc" id="L475">			this.pendingIntents.removeLast();</span>
			// no skill answer and no skill question
<span class="fc bfc" id="L477" title="All 2 branches covered.">			if (answerIsEmpty) {</span>
<span class="fc" id="L478">				Logging.error(&quot;The Skill {} returned no answer and no questions&quot;,</span>
<span class="fc" id="L479">						this.currentSkillStateMachine.getName());</span>
			}
<span class="fc" id="L481">			return;</span>
		}
<span class="fc" id="L483">		Map&lt;String, String&gt; newQuestions = skillAnswer.requiredQuestionsToBeAnswered();</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">		for (Entry&lt;String, String&gt; entry : newQuestions.entrySet()) {</span>
<span class="fc" id="L485">			this.pendingSkillQuestions.addQuestion(this.currentSkillStateMachine.getName(), entry.getKey(),</span>
<span class="fc" id="L486">					entry.getValue());</span>
<span class="fc" id="L487">		}</span>
<span class="fc" id="L488">	}</span>

	/**
	 * Evaluates the next possible action. &lt;br&gt;
	 */
	private void evaluateNextAction() {

		// if the intent is still the same and the skill for the intent has questions
		// left to ask of the user
<span class="fc bfc" id="L497" title="All 6 branches covered.">		if (!this.pendingIntents.isEmpty() &amp;&amp; this.lastIntent.equals(this.pendingIntents.peekLast())</span>
				&amp;&amp; this.currentSkillStateMachine != null
<span class="fc bfc" id="L499" title="All 2 branches covered.">				&amp;&amp; this.pendingSkillQuestions.getNumberOfQuestions(this.currentSkillStateMachine.getName()) &gt; 0) {</span>
<span class="fc" id="L500">			askNextQuestion();</span>
<span class="fc" id="L501">			return;</span>

		}

<span class="fc bfc" id="L505" title="All 2 branches covered.">		if (!this.pendingIntents.isEmpty()) {</span>
<span class="fc" id="L506">			processNextIntent();</span>
		}
<span class="fc" id="L508">	}</span>

	/**
	 * If {@link #lastUsedSkillStateMachine} is null, then the {@link #clearPipeline
	 * pipeline will be cleared} &lt;br&gt;
	 * If not then an abort question will be asked
	 */
	private void abortRequested() {
		// can only abort current skillSM
<span class="fc bfc" id="L517" title="All 2 branches covered.">		if (this.lastUsedSkillStateMachine == null) {</span>
<span class="fc" id="L518">			this.clearPipeline();</span>
<span class="fc" id="L519">			return;</span>
		}
<span class="fc" id="L521">		this.wasLastQuestionAbortQuestion = true;</span>
<span class="fc" id="L522">		askAbortQuestion();</span>
<span class="fc" id="L523">	}</span>

	/**
	 * Resets the {@link ConversationsEngine} to the initial state, except for the
	 * {@link #contextObject}
	 */
	private void clearPipeline() {
		// reset both, the current and last skillStateMachine
<span class="fc" id="L531">		resetCurrentSkillStateMachine(true);</span>
<span class="fc" id="L532">		this.pendingIntents.clear();</span>
<span class="fc" id="L533">		this.pendingSkillQuestions.clear();</span>
<span class="fc" id="L534">		wasLastQuestionChooseSkill = false;</span>
<span class="fc" id="L535">		wasLastQuestionSkillQuestion = false;</span>
<span class="fc" id="L536">		wasLastQuestionAbortQuestion = false;</span>
<span class="fc" id="L537">		wasLastQuestionReturnToPreviousSkill = false;</span>
<span class="fc" id="L538">		possibleSkillsForChooseSkillQuestion.clear();</span>
<span class="fc" id="L539">		lastIntent = &quot;&quot;;</span>
<span class="fc" id="L540">	}</span>

	/**
	 * Creates a new {@link Timer} that transitions the {@link ConversationsEngine}
	 * into the sleepState after {@link #timeoutInSeconds } seconds and if an old
	 * timer exists, cancels it
	 */
	private void scheduleNewTimeoutTask() {
		// This could be extended
<span class="fc" id="L549">		TimerTask timerTask = new TimerTask() {</span>
			@Override
			public void run() {
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">				if (currentState.getName().equals(&quot;defaultState&quot;)) {</span>
<span class="fc" id="L553">					Logging.debug(&quot;Entering Sleep State&quot;);</span>
<span class="fc" id="L554">					currentState = currentState.getNextState(&quot;SLEEP&quot;);</span>
				}
<span class="fc" id="L556">			}</span>
		};
<span class="fc" id="L558">		this.timer.cancel();</span>
<span class="fc" id="L559">		this.timer = new Timer();</span>
<span class="fc" id="L560">		this.timer.schedule(timerTask, this.timeoutInSeconds * 1000L);</span>
<span class="fc" id="L561">	}</span>

	/**
	 * Resets the {@link #timer}.&lt;br&gt;
	 * If the {@link ConversationsEngine} is currently in the sleepState, then it
	 * will transition to the defaultState
	 */
	private void leaveSleepState() {
<span class="fc bfc" id="L569" title="All 2 branches covered.">		if (this.currentState.getName().equals(&quot;sleepState&quot;)) {</span>
<span class="fc" id="L570">			Logging.debug(&quot;Leaving Sleep State&quot;);</span>
<span class="fc" id="L571">			this.currentState = this.currentState.getNextState(&quot;WAKEUP&quot;);</span>
<span class="fc" id="L572">			UserOutput.addOutputMessageFromLocalizationKey(&quot;WelcomeBack&quot;);</span>
		}

<span class="fc" id="L575">		scheduleNewTimeoutTask();</span>
<span class="fc" id="L576">	}</span>

	/**
	 * Adds the next question of a skill to the {@link UserOutput}
	 */
	private void askNextQuestion() {
<span class="fc" id="L582">		String nextQuestion = this.pendingSkillQuestions.getTopQuestion(this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L583">		UserOutput.addOutputQuestion(nextQuestion);</span>
<span class="fc" id="L584">		this.wasLastQuestionSkillQuestion = true;</span>
<span class="fc" id="L585">	}</span>

	/**
	 * Adds the question of choosing a skill to the {@link UserOutput}
	 */
	private void askChooseSkillQuestion() {
<span class="fc" id="L591">		UserOutput.addOutputMessageFromLocalizationKey(&quot;MultipleSkills&quot;,</span>
<span class="fc" id="L592">				this.possibleSkillsForChooseSkillQuestion.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
<span class="fc" id="L593">	}</span>

	/**
	 * Adds the question, weather the user wants to abort the last or all skills, to
	 * the {@link UserOutput}
	 */
	private void askAbortQuestion() {
<span class="fc" id="L600">		UserOutput.addOutputMessageFromLocalizationKey(&quot;AbortQuestion&quot;);</span>
<span class="fc" id="L601">	}</span>

	/**
	 * Adds the question weather the user wants to continue the last skill, to the
	 * {@link UserOutput}
	 */
	private void askContinueLastSkill() {
<span class="fc" id="L608">		UserOutput.addOutputMessageFromLocalizationKey(&quot;ContinueLastSkill&quot;, this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L609">	}</span>

	/**
	 * Determines the possible skills for a given intent
	 * 
	 * @param intent the intent thats supposed to be processed by a skill
	 * @return the {@link SkillStateMachine} to the corresponding skill, that can
	 *         execute the given intent. Or returns null if no or more than one
	 *         skill was found to process the intent
	 */
	private SkillStateMachine getNextSkillStateMachine(String intent) {

<span class="fc bfc" id="L621" title="All 4 branches covered.">		if (this.currentSkillStateMachine != null &amp;&amp; this.currentSkillStateMachine.canExecute(intent)) {</span>
<span class="fc" id="L622">			return this.currentSkillStateMachine;</span>
		}

<span class="fc" id="L625">		List&lt;SkillStateMachine&gt; possibleSkills = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">		for (SkillStateMachine ssm : allSkillStateMachines) {</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">			if (ssm.canExecute(intent)) {</span>
<span class="fc" id="L628">				possibleSkills.add(ssm);</span>
			}
<span class="fc" id="L630">		}</span>

<span class="fc bfc" id="L632" title="All 2 branches covered.">		if (possibleSkills.isEmpty()) {</span>
<span class="fc" id="L633">			UserOutput.addOutputMessageFromLocalizationKey(&quot;NoSkillFound&quot;);</span>
<span class="fc" id="L634">			Logging.debug(&quot;Could not find a skill to process the intent {}&quot;, intent);</span>
<span class="fc" id="L635">			return null;</span>
		}

<span class="fc bfc" id="L638" title="All 2 branches covered.">		if (possibleSkills.size() &gt; 1) {</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">			for (SkillStateMachine ssm : possibleSkills) {</span>
<span class="fc" id="L640">				this.possibleSkillsForChooseSkillQuestion.add(ssm.getName());</span>
<span class="fc" id="L641">			}</span>
<span class="fc" id="L642">			askChooseSkillQuestion();</span>
<span class="fc" id="L643">			Logging.debug(&quot;The intent {} can be processed by multiple skills: {}&quot;, intent,</span>
					this.possibleSkillsForChooseSkillQuestion);
<span class="fc" id="L645">			this.wasLastQuestionChooseSkill = true;</span>
<span class="fc" id="L646">			return null;</span>
		}

<span class="fc bfc" id="L649" title="All 2 branches covered.">		if (this.currentSkillStateMachine != null</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">				&amp;&amp; !possibleSkills.get(0).getName().equals(currentSkillStateMachine.getName())) {</span>
<span class="fc" id="L651">			leaveCurrentSkillStateMachine();</span>
		}
<span class="fc" id="L653">		return possibleSkills.get(0);</span>

	}

	/**
	 * leaves the {@link #currentSkillStateMachine} and sets it as the
	 * {@link #lastUsedSkillStateMachine}
	 */
	private void leaveCurrentSkillStateMachine() {
<span class="fc bfc" id="L662" title="All 2 branches covered.">		if (this.currentSkillStateMachine != null) {</span>
<span class="fc" id="L663">			Logging.debug(&quot;Leaving the skill {}&quot;, this.currentSkillStateMachine.getName());</span>
		}
<span class="fc" id="L665">		this.lastUsedSkillStateMachine = this.currentSkillStateMachine;</span>
<span class="fc" id="L666">	}</span>

	/**
	 * Resets the {@link #currentSkillStateMachine} and removes all pending
	 * questions relating to the skill
	 * 
	 * @param alsoResetLastUsedSkillStateMachine if true, then also resets the
	 *                                           {@link #lastUsedSkillStateMachine}
	 *                                           and removes all pending questions
	 *                                           relating to that skill
	 */
	private void resetCurrentSkillStateMachine(boolean alsoResetLastUsedSkillStateMachine) {
<span class="fc bfc" id="L678" title="All 2 branches covered.">		if (this.currentSkillStateMachine == null) {</span>
<span class="fc" id="L679">			return;</span>
		}
<span class="fc" id="L681">		removeIntentsOfCurrentSkill();</span>
<span class="fc" id="L682">		this.currentSkillStateMachine.reset();</span>
<span class="fc" id="L683">		this.pendingSkillQuestions.removeAllSkillQuestions(this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L684">		this.wasLastQuestionSkillQuestion = false;</span>
<span class="fc" id="L685">		this.currentSkillStateMachine = this.lastUsedSkillStateMachine;</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">		if (alsoResetLastUsedSkillStateMachine) {</span>
<span class="fc" id="L687">			resetCurrentSkillStateMachine(false);</span>
		}
<span class="fc" id="L689">	}</span>

	/**
	 * Removes all {@link #pendingIntents} that the
	 * {@link #currentSkillStateMachine} can execute
	 */
	private void removeIntentsOfCurrentSkill() {
<span class="fc" id="L696">		Iterator&lt;String&gt; iterator = this.pendingIntents.iterator();</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">		while (iterator.hasNext()) {</span>
<span class="fc" id="L698">			String intent = iterator.next();</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">			if (this.currentSkillStateMachine.canExecute(intent)) {</span>
<span class="fc" id="L700">				iterator.remove();</span>
			}
<span class="fc" id="L702">		}</span>
<span class="fc" id="L703">	}</span>

	/**
	 * Checks weather the {@link #currentSkillStateMachine} has ended or not
	 * 
	 * @return true if the {@link #currentSkillStateMachine} has ended
	 */
	private boolean hasSkillStateMachineEnded() {
<span class="fc" id="L711">		boolean currentSkillStateMachineEnded = this.currentSkillStateMachine.hasEnded();</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">		if (currentSkillStateMachineEnded) {</span>
<span class="fc" id="L713">			Logging.debug(&quot;The Skill {} Ended&quot;, this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L714">			resetCurrentSkillStateMachine(false);</span>
<span class="fc" id="L715">			this.currentSkillStateMachine = this.lastUsedSkillStateMachine;</span>
<span class="fc" id="L716">			this.lastUsedSkillStateMachine = null;</span>
		}

<span class="fc" id="L719">		return currentSkillStateMachineEnded;</span>
	}

	/**
	 * Logs that a method on this object was called after it has been shut down
	 */
	private void logIllegalAccess() {
<span class="fc" id="L726">		Logging.error(&quot;The ConversationsEngine was invoked after it has been shut down&quot;);</span>
<span class="fc" id="L727">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>