<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConversationsEngine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">conversations-engine</a> &gt; <a href="index.source.html" class="el_package">statemachine</a> &gt; <span class="el_source">ConversationsEngine.java</span></div><h1>ConversationsEngine.java</h1><pre class="source lang-java linenums">package statemachine;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Timer;
import java.util.TimerTask;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import org.json.JSONObject;

import interfaces.INLPAnswer;
import interfaces.INLPComponent;
import interfaces.ISkill;
import interfaces.ISkillAnswer;

/**
 * The ConversationsEngineStateMachine is a ChatBot-Framework to TODO: finish
 * this
 * 
 * @author Marcel Engelmann
 *
 */
public class ConversationsEngine {

	private static final int DEFAULTTIMEOUTVALUE = 300;
	private static final String EMPTYCONTEXTOBJECT = &quot;{}&quot;;

	private State currentState;
	private SkillStateMachine currentSkillStateMachine;
	private SkillStateMachine lastUsedSkillStateMachine;
	private PendingQuestions pendingSkillQuestions;
	private JSONObject contextObject;
	private Timer timer;
	private String lastIntent;
	private INLPComponent nlpComponent;
	private List&lt;String&gt; possibleSkillsForChooseSkillQuestion;
	private List&lt;SkillStateMachine&gt; allSkillStateMachines;
	private Deque&lt;String&gt; pendingIntents;
	private boolean wasLastQuestionChooseSkill;
	private boolean wasLastQuestionSkillQuestion;
	private boolean wasLastQuestionAbortQuestion;
	private boolean wasLastQuestionReturnToPreviousSkill;
	private boolean closed;
	private int timeoutInSeconds;

	/**
	 * Creates a new {@link ConversationsEngine} object
	 * 
	 * @param nlpComponent      the NLPComponent that handles the user input
	 * @param timeoutInSeconds  the number of seconds after which the
	 *                          {@link ConversationsEngine} will transition into the
	 *                          sleepState. The timer refreshes after each
	 *                          interaction.
	 * @param jsonContextObject the contextObject as JSON-String to start the
	 *                          {@link ConversationsEngine} with
	 * @throws IllegalArgumentException if the {@link INLPComponent} is null or the
	 *                                  timeout value is less than 1
	 */
	public ConversationsEngine(INLPComponent nlpComponent, int timeoutInSeconds, String jsonContextObject)
<span class="fc" id="L68">			throws IllegalArgumentException {</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">		if (nlpComponent == null) {</span>
<span class="fc" id="L70">			Logging.error(&quot;INLPComponent is null&quot;);</span>
<span class="fc" id="L71">			throw new IllegalArgumentException(&quot;INLPComponent is null&quot;);</span>
		}

<span class="fc bfc" id="L74" title="All 2 branches covered.">		if (timeoutInSeconds &lt;= 0) {</span>
<span class="fc" id="L75">			Logging.error(&quot;Timeout value must be greater than 0&quot;);</span>
<span class="fc" id="L76">			throw new IllegalArgumentException(&quot;Timeout value must be greater than 0&quot;);</span>
		}
<span class="fc" id="L78">		State defaultState = new State(&quot;defaultState&quot;);</span>
<span class="fc" id="L79">		State sleepState = new State(&quot;sleepState&quot;);</span>
<span class="fc" id="L80">		defaultState.addTransition(new Transition(sleepState, &quot;SLEEP&quot;));</span>
<span class="fc" id="L81">		sleepState.addTransition(new Transition(defaultState, &quot;WAKEUP&quot;));</span>
<span class="fc" id="L82">		this.currentState = defaultState;</span>
<span class="fc" id="L83">		this.nlpComponent = nlpComponent;</span>
<span class="fc" id="L84">		this.contextObject = new JSONObject(jsonContextObject);</span>
<span class="fc" id="L85">		this.allSkillStateMachines = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L86">		this.possibleSkillsForChooseSkillQuestion = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L87">		this.pendingSkillQuestions = new PendingQuestions();</span>
<span class="fc" id="L88">		this.pendingIntents = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L89">		this.lastIntent = &quot;&quot;;</span>
<span class="fc" id="L90">		this.wasLastQuestionChooseSkill = false;</span>
<span class="fc" id="L91">		this.wasLastQuestionSkillQuestion = false;</span>
<span class="fc" id="L92">		this.wasLastQuestionAbortQuestion = false;</span>
<span class="fc" id="L93">		this.wasLastQuestionReturnToPreviousSkill = false;</span>
<span class="fc" id="L94">		this.closed = false;</span>
<span class="fc" id="L95">		this.timeoutInSeconds = timeoutInSeconds;</span>
<span class="fc" id="L96">		I18n.setLanguage(new Locale(&quot;de&quot;, &quot;DE&quot;));</span>
		// the list of intents the ConversationsEngine uses itself (as trigger words)
<span class="fc" id="L98">		List&lt;String&gt; triggerIntents = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L99">		triggerIntents.add(&quot;abort&quot;);</span>
<span class="fc" id="L100">		triggerIntents.add(&quot;last&quot;);</span>
<span class="fc" id="L101">		triggerIntents.add(&quot;all&quot;);</span>
<span class="fc" id="L102">		triggerIntents.add(&quot;yes&quot;);</span>
<span class="fc" id="L103">		triggerIntents.add(&quot;no&quot;);</span>
<span class="fc" id="L104">		this.nlpComponent.addUsedIntents(triggerIntents);</span>
<span class="fc" id="L105">		this.timer = new Timer();</span>
<span class="fc" id="L106">		scheduleNewTimeoutTask();</span>
<span class="fc" id="L107">	}</span>

	/**
	 * Creates a new {@link ConversationsEngine} object with a default timeout of
	 * 300 seconds and an empty context object
	 * 
	 * @param nlpComponent the NLPComponent that handles the user input
	 */
	public ConversationsEngine(INLPComponent nlpComponent) {
<span class="fc" id="L116">		this(nlpComponent, DEFAULTTIMEOUTVALUE, EMPTYCONTEXTOBJECT);</span>
<span class="fc" id="L117">	}</span>

	/**
	 * Creates a new {@link ConversationsEngine} object with an empty context object
	 * 
	 * @param nlpComponent     the NLPComponent that handles the user input
	 * @param timeoutInSeconds the number of seconds after which the
	 *                         {@link ConversationsEngine} will transition into the
	 *                         sleepState. The timer refreshes after each
	 *                         interaction.
	 */
	public ConversationsEngine(INLPComponent nlpComponent, int timeoutInSeconds) {
<span class="fc" id="L129">		this(nlpComponent, timeoutInSeconds, EMPTYCONTEXTOBJECT);</span>
<span class="fc" id="L130">	}</span>

	/**
	 * Creates a new {@link ConversationsEngine} object with a default timeout of
	 * 300 seconds
	 * 
	 * @param nlpComponent      the NLPComponent that handles the user input
	 * @param jsonContextObject the contextObject as JSON-String to start the
	 *                          {@link ConversationsEngine} with
	 */
	public ConversationsEngine(INLPComponent nlpComponent, String jsonContextObject) {
<span class="fc" id="L141">		this(nlpComponent, DEFAULTTIMEOUTVALUE, jsonContextObject);</span>
<span class="fc" id="L142">	}</span>

	/**
	 * Returns the state machine's current state
	 * 
	 * @return the state machine's current state
	 */
	public String getState() {
<span class="fc bfc" id="L150" title="All 2 branches covered.">		if (this.closed) {</span>
<span class="fc" id="L151">			logIllegalAccess();</span>
<span class="fc" id="L152">			return &quot;&quot;;</span>
		}
<span class="fc bfc" id="L154" title="All 2 branches covered.">		if (this.currentSkillStateMachine != null)</span>
<span class="fc" id="L155">			return this.currentSkillStateMachine.getCurrentState().getName();</span>
<span class="fc" id="L156">		return this.currentState.getName();</span>
	}

	/**
	 * Add a new Skill to the {@link ConversationsEngine}
	 * 
	 * @param skill            the skill to add to the {@link ConversationsEngine}
	 * @param jsonStateMachine the skill's state machine in JSON-Format. For the
	 *                         JSON-Schema please check out the &lt;a href=
	 *                         &quot;file:../../resources/SkillStateMachine_Schema.json&quot;&gt;Schema.json&lt;/a&gt;
	 *                         file
	 */
	public void addSkill(ISkill skill, String jsonStateMachine) {
<span class="fc bfc" id="L169" title="All 2 branches covered.">		if (this.closed) {</span>
<span class="fc" id="L170">			logIllegalAccess();</span>
<span class="fc" id="L171">			return;</span>
		}
<span class="fc bfc" id="L173" title="All 2 branches covered.">		if (skill == null) {</span>
<span class="fc" id="L174">			Logging.error(&quot;The skill to add to the ConversationsEngine is null&quot;);</span>
<span class="fc" id="L175">			return;</span>
		}

<span class="fc bfc" id="L178" title="All 2 branches covered.">		if (jsonStateMachine.isBlank()) {</span>
<span class="fc" id="L179">			Logging.error(&quot;The JSON-String for the skill to add to the ConversationsEngine is blank&quot;, skill);</span>
<span class="fc" id="L180">			return;</span>
		}
<span class="fc" id="L182">		SkillStateMachine newSkillStateMachine = GenerateSkillStateMachine.fromJson(skill, jsonStateMachine,</span>
				nlpComponent);
<span class="fc bfc" id="L184" title="All 2 branches covered.">		if (newSkillStateMachine == null) {</span>
<span class="fc" id="L185">			Logging.error(&quot;Could not add the skill from the jsonString {}&quot;, jsonStateMachine);</span>
<span class="fc" id="L186">			return;</span>
		}

<span class="fc bfc" id="L189" title="All 2 branches covered.">		if (allSkillStateMachines.stream().anyMatch(</span>
<span class="fc" id="L190">				skillStateMachine -&gt; skillStateMachine.getName().equalsIgnoreCase(newSkillStateMachine.getName()))) {</span>
<span class="fc" id="L191">			Logging.error(&quot;The skill {} already exists&quot;, newSkillStateMachine.getName());</span>
<span class="fc" id="L192">			return;</span>
		}

<span class="fc" id="L195">		allSkillStateMachines.add(newSkillStateMachine);</span>
<span class="fc" id="L196">	}</span>

	/**
	 * Shuts this ConversationsEngine object down and returns the current context
	 * object to the given operation
	 * 
	 * @param operation the operation to call, with the context object passed as
	 *                  parameter, after shutting down.
	 */
	public void shutdown(Consumer&lt;StringBuffer&gt; operation) {
<span class="fc bfc" id="L206" title="All 2 branches covered.">		if (this.closed) {</span>
<span class="fc" id="L207">			logIllegalAccess();</span>
<span class="fc" id="L208">			return;</span>
		}
<span class="fc" id="L210">		Logging.debug(&quot;Shutting down the ConversationsEngine {}&quot;, this);</span>
<span class="fc" id="L211">		this.timer.cancel();</span>
<span class="fc" id="L212">		this.closed = true;</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">		if (operation == null) {</span>
<span class="fc" id="L214">			Logging.warn(&quot;The consumer passed to the shutdown function was null&quot;);</span>
<span class="fc" id="L215">			return;</span>
		}
<span class="fc" id="L217">		StringBuffer buffer = new StringBuffer();</span>
<span class="fc" id="L218">		buffer.append(this.contextObject);</span>
<span class="fc" id="L219">		this.contextObject = new JSONObject();</span>
<span class="fc" id="L220">		operation.accept(buffer);</span>
<span class="fc" id="L221">	}</span>

	/**
	 * Processes a new input and returns a {@link List} of answers
	 * 
	 * @param input the input to process
	 * @return a {@link List} of answers
	 */
	public List&lt;String&gt; userInput(String input) {
<span class="fc bfc" id="L230" title="All 2 branches covered.">		if (this.closed) {</span>
<span class="fc" id="L231">			logIllegalAccess();</span>
<span class="fc" id="L232">			return new ArrayList&lt;&gt;();</span>
		}
<span class="fc bfc" id="L234" title="All 4 branches covered.">		if (input == null || input.isBlank()) {</span>
<span class="fc" id="L235">			Logging.warn(&quot;The user input was null or blank&quot;);</span>
<span class="fc" id="L236">			UserOutput.addDefaultErrorMessage();</span>
<span class="fc" id="L237">			return UserOutput.popNextOutput();</span>
		}
<span class="fc" id="L239">		Logging.userInput(input);</span>
<span class="fc" id="L240">		leaveSleepState();</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">		if (this.wasLastQuestionSkillQuestion) {</span>
<span class="fc" id="L242">			processSkillQuestion(input);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">		} else if (this.wasLastQuestionChooseSkill) {</span>
<span class="fc" id="L244">			processChooseSkillQuestion(input);</span>
		} else {
<span class="fc" id="L246">			processNormalRequest(input);</span>
		}

<span class="fc" id="L249">		return UserOutput.popNextOutput();</span>
	}

	/**
	 * Processes the input normally as a new input not relating to a question asked
	 * previously
	 * 
	 * @param input the user input
	 */
	private void processNormalRequest(String input) {
<span class="fc" id="L259">		processINLPAnswer(this.nlpComponent.understandInput(input, this.contextObject));</span>

<span class="fc" id="L261">	}</span>

	/**
	 * Processes the input normally as a new input not relating to a question asked
	 * previously
	 * 
	 * @param processedInput the {@link INLPAnswer} of a {@link INLPComponent}
	 */
	private void processINLPAnswer(INLPAnswer processedInput) {
<span class="fc bfc" id="L270" title="All 2 branches covered.">		if (processedInput == null) {</span>
<span class="fc" id="L271">			Logging.error(&quot;NLP Component's returned INLPAnswer is null&quot;);</span>
<span class="fc" id="L272">			UserOutput.addDefaultErrorMessage();</span>
<span class="fc" id="L273">			return;</span>
		}
<span class="fc" id="L275">		List&lt;String&gt; intents = processedInput.getIntents();</span>
<span class="fc" id="L276">		Locale foundLanguage = processedInput.getInputLanguage();</span>
<span class="fc" id="L277">		boolean addedEntities = processedInput.hasAddedEntities();</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">		if (foundLanguage == null) {</span>
<span class="fc" id="L279">			Logging.error(&quot;NLPComponent did not return a language&quot;);</span>
		} else {
<span class="fc" id="L281">			I18n.setLanguage(foundLanguage);</span>
		}
		// If the NLPAnswer has no result -&gt; treat it as bad input
<span class="fc bfc" id="L284" title="All 6 branches covered.">		if (!addedEntities &amp;&amp; (intents == null || intents.isEmpty())) {</span>
<span class="fc" id="L285">			UserOutput.addDefaultErrorMessage();</span>
<span class="fc" id="L286">			return;</span>
		}
<span class="pc bpc" id="L288" title="1 of 4 branches missed.">		if (intents != null &amp;&amp; !intents.isEmpty()) {</span>
			// keep the correct input order for the stack/dequeue
<span class="fc" id="L290">			Collections.reverse(intents);</span>
<span class="fc" id="L291">			this.pendingIntents.addAll(intents);</span>
<span class="fc bfc" id="L292" title="All 4 branches covered.">			if (this.wasLastQuestionAbortQuestion || this.wasLastQuestionReturnToPreviousSkill) {</span>
<span class="fc" id="L293">				processSpecialQuestion();</span>
<span class="fc" id="L294">				return;</span>
			}
<span class="fc bfc" id="L296" title="All 2 branches covered.">			if (&quot;abort&quot;.equalsIgnoreCase(intents.get(0))) {</span>
<span class="fc" id="L297">				this.pendingIntents.removeLast();</span>
<span class="fc" id="L298">				abortRequested();</span>
<span class="fc" id="L299">				return;</span>
			}
		}
<span class="fc" id="L302">		evaluateNextAction();</span>
<span class="fc" id="L303">	}</span>

	private void processSpecialQuestion() {
<span class="fc bfc" id="L306" title="All 2 branches covered.">		if (this.wasLastQuestionAbortQuestion) {</span>
<span class="fc" id="L307">			this.wasLastQuestionAbortQuestion = false;</span>
<span class="fc" id="L308">			processAbortQuestion();</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">		} else if (wasLastQuestionReturnToPreviousSkill) {</span>
<span class="fc" id="L310">			this.wasLastQuestionReturnToPreviousSkill = false;</span>
<span class="fc" id="L311">			processReturnToPreviousSkillQuestion();</span>
		}

<span class="fc" id="L314">	}</span>

	/**
	 * Tries to process the intent as an answer to an abort question &lt;br&gt;
	 * &lt;br&gt;
	 * If the answer was to abort the last skill, then the
	 * {@link #currentSkillStateMachine} will be
	 * {@link #resetCurrentSkillStateMachine reset} and the next action will be
	 * {@link #evaluateNextAction() evaluated} &lt;br&gt;
	 * 
	 * If the answer was to abort all skills, then the pipeline will be
	 * {@link #clearPipeline cleared} &lt;br&gt;
	 * If the abort question was not answered, the input will be processed
	 * {@link #processNormalRequest(String)}
	 * 
	 * @param intent the intent to process
	 */
	private void processAbortQuestion() {
<span class="fc" id="L332">		String intent = this.pendingIntents.peekLast();</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">		if (&quot;last&quot;.equalsIgnoreCase(intent)) {</span>
<span class="fc" id="L334">			this.pendingIntents.removeLast();</span>
<span class="fc" id="L335">			resetCurrentSkillStateMachine(false);</span>
<span class="fc" id="L336">			UserOutput.addOutputMessageFromLocalizationKey(&quot;BackToSkill&quot;, this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L337">			evaluateNextAction();</span>
<span class="fc" id="L338">			return;</span>
		}
<span class="fc bfc" id="L340" title="All 2 branches covered.">		if (&quot;all&quot;.equalsIgnoreCase(intent)) {</span>
<span class="fc" id="L341">			this.pendingIntents.removeLast();</span>
<span class="fc" id="L342">			this.clearPipeline();</span>
<span class="fc" id="L343">			return;</span>
		}
<span class="fc" id="L345">		askAbortQuestion();</span>
<span class="fc" id="L346">	}</span>

	/**
	 * Tries to process the intent as an answer to the &quot;Return to the previous
	 * skill&quot; question&lt;br&gt;
	 * &lt;br&gt;
	 * 
	 * If the answer was to return to the next skill, then the
	 * {@link #currentSkillStateMachine} will be
	 * {@link #resetCurrentSkillStateMachine(boolean) reset}&lt;br&gt;
	 * 
	 * If the answer was to abort all skills, then the pipeline will be
	 * {@link #clearPipeline() cleared}&lt;br&gt;
	 * 
	 * If the abort question was not answered, the input will be processed
	 * {@link #processNormalRequest normally}
	 * 
	 * @param intent the intent to process
	 * 
	 */
	private void processReturnToPreviousSkillQuestion() {
<span class="fc" id="L367">		String intent = this.pendingIntents.peekLast();</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">		if (&quot;Yes&quot;.equalsIgnoreCase(intent)) {</span>
<span class="fc" id="L369">			this.pendingIntents.removeLast();</span>
<span class="fc" id="L370">			UserOutput.addOutputMessageFromLocalizationKey(&quot;BackToSkill&quot;, this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L371">			evaluateNextAction();</span>
<span class="fc" id="L372">			return;</span>
		}
<span class="fc bfc" id="L374" title="All 2 branches covered.">		if (&quot;No&quot;.equalsIgnoreCase(intent)) {</span>
<span class="fc" id="L375">			this.pendingIntents.removeLast();</span>
<span class="fc" id="L376">			resetCurrentSkillStateMachine(true);</span>
<span class="fc" id="L377">			return;</span>
		}
<span class="fc" id="L379">		askContinueLastSkill();</span>
<span class="fc" id="L380">	}</span>

	/**
	 * Tries to process the input as an answer to a skill question. If the question
	 * was not answered, the corresponding skill will have to ask the question again
	 * 
	 * @param input the input to process
	 */
	private void processSkillQuestion(String input) {
<span class="fc" id="L389">		this.wasLastQuestionSkillQuestion = false;</span>
<span class="fc" id="L390">		String entityName = &quot;&quot;;</span>
		INLPAnswer processedInput;
<span class="fc" id="L392">		entityName = this.pendingSkillQuestions.getTopEntity(this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L393">		processedInput = this.nlpComponent.understandInput(input, entityName, this.contextObject);</span>
		// Remove last asked question. If the question was not answered, then the
		// corresponding skill will have to ask the same question again
<span class="fc" id="L396">		this.pendingSkillQuestions.removeTopQuestionAndEntity(this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L397">		processINLPAnswer(processedInput);</span>
<span class="fc" id="L398">	}</span>

	/**
	 * Tries to process the input as an answer to a question to choose a skill&lt;br&gt;
	 * &lt;br&gt;
	 * If the input equals to a fitting skill, that skill will be executed and the
	 * last intent will be processed Otherwise the input will be processed as a
	 * {@link #processNormalRequest normal request}
	 * 
	 * @param input the input to process
	 */
	private void processChooseSkillQuestion(String input) {
		// match input to possible skills to choose from
<span class="fc" id="L411">		String nextSkill = this.possibleSkillsForChooseSkillQuestion.stream().filter(input::equalsIgnoreCase)</span>
<span class="fc" id="L412">				.findFirst().orElse(&quot;&quot;);</span>

<span class="fc bfc" id="L414" title="All 2 branches covered.">		if (nextSkill.isEmpty()) {</span>
<span class="fc" id="L415">			Logging.debug(</span>
					&quot;The question to choose a skill was not answered!\nPossible skills are: {}\nUser input is: {}&quot;,
					this.possibleSkillsForChooseSkillQuestion, input);
<span class="fc" id="L418">			askChooseSkillQuestion();</span>
		} else {
<span class="fc" id="L420">			this.wasLastQuestionChooseSkill = false;</span>
<span class="fc" id="L421">			final String skillName = nextSkill;</span>
<span class="fc" id="L422">			leaveCurrentSkillStateMachine();</span>
<span class="fc" id="L423">			this.currentSkillStateMachine = this.allSkillStateMachines.stream()</span>
<span class="fc" id="L424">					.filter(skill -&gt; skill.getName().equals(skillName)).findFirst().orElse(null);</span>
<span class="fc" id="L425">			evaluateNextAction();</span>
		}
<span class="fc" id="L427">	}</span>

	/**
	 * Processes the next {@link #pendingIntents intent}
	 *
	 */
	private void processNextIntent() {
<span class="fc" id="L434">		String intent = pendingIntents.peekLast();</span>
<span class="fc" id="L435">		Logging.debug(&quot;Processing the intent '{}'&quot;, intent);</span>
<span class="fc" id="L436">		this.lastIntent = intent;</span>
<span class="fc" id="L437">		SkillStateMachine nextSkillStateMachine = getNextSkillStateMachine(intent);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">		if (nextSkillStateMachine == null) {</span>
<span class="fc" id="L439">			return;</span>
		}
<span class="fc" id="L441">		this.currentSkillStateMachine = nextSkillStateMachine;</span>

<span class="fc" id="L443">		ISkillAnswer answer = this.currentSkillStateMachine.execute(intent, this.contextObject);</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">		if (answer == null) {</span>
<span class="fc" id="L445">			UserOutput.addDefaultErrorMessage();</span>
<span class="fc" id="L446">			return;</span>
		}

<span class="fc" id="L449">		this.processSkillAnswer(answer);</span>
<span class="fc" id="L450">		boolean skillMachineEnded = this.hasSkillStateMachineEnded();</span>
<span class="fc bfc" id="L451" title="All 4 branches covered.">		if (skillMachineEnded &amp;&amp; this.currentSkillStateMachine != null) {</span>
<span class="fc" id="L452">			wasLastQuestionReturnToPreviousSkill = true;</span>
<span class="fc" id="L453">			askContinueLastSkill();</span>
<span class="fc" id="L454">			return;</span>
		}
<span class="fc" id="L456">		evaluateNextAction();</span>
<span class="fc" id="L457">	}</span>

	/**
	 * Processes a {@link ISkillAnswer} of a skill
	 * 
	 * @param skillAnswer the answer of a skill
	 */
	private void processSkillAnswer(ISkillAnswer skillAnswer) {
<span class="fc" id="L465">		boolean answerIsEmpty = true;</span>
<span class="fc bfc" id="L466" title="All 4 branches covered.">		if (skillAnswer.answers() != null &amp;&amp; !skillAnswer.answers().isEmpty()) {</span>
<span class="fc" id="L467">			UserOutput.addOutputMessages(skillAnswer.answers());</span>
<span class="fc" id="L468">			answerIsEmpty = false;</span>
		}
<span class="fc bfc" id="L470" title="All 2 branches covered.">		if (skillAnswer.skipUserOutput()) {</span>
<span class="fc" id="L471">			Logging.debug(&quot;Skipping user Output&quot;);</span>
<span class="fc" id="L472">			return;</span>
		}
<span class="fc bfc" id="L474" title="All 2 branches covered.">		if (skillAnswer.requiredQuestionsToBeAnswered() == null</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">				|| skillAnswer.requiredQuestionsToBeAnswered().isEmpty()) {</span>
			// remove last processed intent
<span class="fc" id="L477">			this.pendingIntents.removeLast();</span>
			// no skill answer and no skill question
<span class="fc bfc" id="L479" title="All 2 branches covered.">			if (answerIsEmpty) {</span>
<span class="fc" id="L480">				Logging.error(&quot;The Skill {} returned no answer and no questions&quot;,</span>
<span class="fc" id="L481">						this.currentSkillStateMachine.getName());</span>
			}
<span class="fc" id="L483">			return;</span>
		}
<span class="fc" id="L485">		Map&lt;String, String&gt; newQuestions = skillAnswer.requiredQuestionsToBeAnswered();</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">		for (Entry&lt;String, String&gt; entry : newQuestions.entrySet()) {</span>
<span class="fc" id="L487">			this.pendingSkillQuestions.addQuestion(this.currentSkillStateMachine.getName(), entry.getKey(),</span>
<span class="fc" id="L488">					entry.getValue());</span>
<span class="fc" id="L489">		}</span>
<span class="fc" id="L490">	}</span>

	/**
	 * Evaluates the next possible action. &lt;br&gt;
	 */
	private void evaluateNextAction() {

		// if the intent is still the same and the skill for the intent has questions
		// left to ask of the user
<span class="fc bfc" id="L499" title="All 4 branches covered.">		if (this.currentSkillStateMachine != null &amp;&amp; !this.pendingIntents.isEmpty()</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">				&amp;&amp; this.lastIntent.equals(this.pendingIntents.peekLast())</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">				&amp;&amp; this.pendingSkillQuestions.getNumberOfQuestions(this.currentSkillStateMachine.getName()) &gt; 0) {</span>
<span class="fc" id="L502">			askNextQuestion();</span>
<span class="fc" id="L503">			return;</span>

		}

<span class="fc bfc" id="L507" title="All 2 branches covered.">		if (!this.pendingIntents.isEmpty()) {</span>
<span class="fc" id="L508">			processNextIntent();</span>
		}
<span class="fc" id="L510">	}</span>

	/**
	 * If {@link #lastUsedSkillStateMachine} is null, then the {@link #clearPipeline
	 * pipeline will be cleared} &lt;br&gt;
	 * If not then an abort question will be asked
	 */
	private void abortRequested() {
		// can only abort current skillSM
<span class="fc bfc" id="L519" title="All 2 branches covered.">		if (this.lastUsedSkillStateMachine == null) {</span>
<span class="fc" id="L520">			this.clearPipeline();</span>
<span class="fc" id="L521">			return;</span>
		}
<span class="fc" id="L523">		this.wasLastQuestionAbortQuestion = true;</span>
<span class="fc" id="L524">		askAbortQuestion();</span>
<span class="fc" id="L525">	}</span>

	/**
	 * Resets the {@link ConversationsEngine} to the initial state, except for the
	 * {@link #contextObject}
	 */
	private void clearPipeline() {
		// reset both, the current and last skillStateMachine
<span class="fc" id="L533">		resetCurrentSkillStateMachine(true);</span>
<span class="fc" id="L534">		this.pendingIntents.clear();</span>
<span class="fc" id="L535">		this.pendingSkillQuestions.clear();</span>
<span class="fc" id="L536">		wasLastQuestionChooseSkill = false;</span>
<span class="fc" id="L537">		wasLastQuestionSkillQuestion = false;</span>
<span class="fc" id="L538">		wasLastQuestionAbortQuestion = false;</span>
<span class="fc" id="L539">		wasLastQuestionReturnToPreviousSkill = false;</span>
<span class="fc" id="L540">		possibleSkillsForChooseSkillQuestion.clear();</span>
<span class="fc" id="L541">		lastIntent = &quot;&quot;;</span>
<span class="fc" id="L542">	}</span>

	/**
	 * Creates a new {@link Timer} that transitions the {@link ConversationsEngine}
	 * into the sleepState after {@link #timeoutInSeconds } seconds and if an old
	 * timer exists, cancels it
	 */
	private void scheduleNewTimeoutTask() {
		// This could be extended
<span class="fc" id="L551">		TimerTask timerTask = new TimerTask() {</span>
			@Override
			public void run() {
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">				if (&quot;defaultState&quot;.equals(currentState.getName())) {</span>
<span class="fc" id="L555">					Logging.debug(&quot;Entering Sleep State&quot;);</span>
<span class="fc" id="L556">					currentState = currentState.getNextState(&quot;SLEEP&quot;);</span>
				}
<span class="fc" id="L558">			}</span>
		};
<span class="fc" id="L560">		this.timer.cancel();</span>
<span class="fc" id="L561">		this.timer = new Timer();</span>
<span class="fc" id="L562">		this.timer.schedule(timerTask, this.timeoutInSeconds * 1000L);</span>
<span class="fc" id="L563">	}</span>

	/**
	 * Resets the {@link #timer}.&lt;br&gt;
	 * If the {@link ConversationsEngine} is currently in the sleepState, then it
	 * will transition to the defaultState
	 */
	private void leaveSleepState() {
<span class="fc bfc" id="L571" title="All 2 branches covered.">		if (&quot;sleepState&quot;.equals(this.currentState.getName())) {</span>
<span class="fc" id="L572">			Logging.debug(&quot;Leaving Sleep State&quot;);</span>
<span class="fc" id="L573">			this.currentState = this.currentState.getNextState(&quot;WAKEUP&quot;);</span>
<span class="fc" id="L574">			UserOutput.addOutputMessageFromLocalizationKey(&quot;WelcomeBack&quot;);</span>
		}

<span class="fc" id="L577">		scheduleNewTimeoutTask();</span>
<span class="fc" id="L578">	}</span>

	/**
	 * Adds the next question of a skill to the {@link UserOutput}
	 */
	private void askNextQuestion() {
<span class="fc" id="L584">		String nextQuestion = this.pendingSkillQuestions.getTopQuestion(this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L585">		UserOutput.addOutputQuestion(nextQuestion);</span>
<span class="fc" id="L586">		this.wasLastQuestionSkillQuestion = true;</span>
<span class="fc" id="L587">	}</span>

	/**
	 * Adds the question of choosing a skill to the {@link UserOutput}
	 */
	private void askChooseSkillQuestion() {
<span class="fc" id="L593">		UserOutput.addOutputMessageFromLocalizationKey(&quot;MultipleSkills&quot;,</span>
<span class="fc" id="L594">				this.possibleSkillsForChooseSkillQuestion.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
<span class="fc" id="L595">	}</span>

	/**
	 * Adds the question, weather the user wants to abort the last or all skills, to
	 * the {@link UserOutput}
	 */
	private void askAbortQuestion() {
<span class="fc" id="L602">		UserOutput.addOutputMessageFromLocalizationKey(&quot;AbortQuestion&quot;);</span>
<span class="fc" id="L603">	}</span>

	/**
	 * Adds the question weather the user wants to continue the last skill, to the
	 * {@link UserOutput}
	 */
	private void askContinueLastSkill() {
<span class="fc" id="L610">		UserOutput.addOutputMessageFromLocalizationKey(&quot;ContinueLastSkill&quot;, this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L611">	}</span>

	/**
	 * Determines the possible skills for a given intent
	 * 
	 * @param intent the intent thats supposed to be processed by a skill
	 * @return the {@link SkillStateMachine} to the corresponding skill, that can
	 *         execute the given intent. Or returns null if no or more than one
	 *         skill was found to process the intent
	 */
	private SkillStateMachine getNextSkillStateMachine(String intent) {

<span class="fc bfc" id="L623" title="All 4 branches covered.">		if (this.currentSkillStateMachine != null &amp;&amp; this.currentSkillStateMachine.canExecute(intent)) {</span>
<span class="fc" id="L624">			return this.currentSkillStateMachine;</span>
		}

<span class="fc" id="L627">		List&lt;SkillStateMachine&gt; possibleSkills = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">		for (SkillStateMachine ssm : allSkillStateMachines) {</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">			if (ssm.canExecute(intent)) {</span>
<span class="fc" id="L630">				possibleSkills.add(ssm);</span>
			}
<span class="fc" id="L632">		}</span>

<span class="fc bfc" id="L634" title="All 2 branches covered.">		if (possibleSkills.isEmpty()) {</span>
<span class="fc" id="L635">			UserOutput.addOutputMessageFromLocalizationKey(&quot;NoSkillFound&quot;);</span>
<span class="fc" id="L636">			Logging.debug(&quot;Could not find a skill to process the intent {}&quot;, intent);</span>
<span class="fc" id="L637">			return null;</span>
		}

<span class="fc bfc" id="L640" title="All 2 branches covered.">		if (possibleSkills.size() &gt; 1) {</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">			for (SkillStateMachine ssm : possibleSkills) {</span>
<span class="fc" id="L642">				this.possibleSkillsForChooseSkillQuestion.add(ssm.getName());</span>
<span class="fc" id="L643">			}</span>
<span class="fc" id="L644">			askChooseSkillQuestion();</span>
<span class="fc" id="L645">			Logging.debug(&quot;The intent {} can be processed by multiple skills: {}&quot;, intent,</span>
					this.possibleSkillsForChooseSkillQuestion);
<span class="fc" id="L647">			this.wasLastQuestionChooseSkill = true;</span>
<span class="fc" id="L648">			return null;</span>
		}

<span class="fc bfc" id="L651" title="All 2 branches covered.">		if (this.currentSkillStateMachine != null</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">				&amp;&amp; !possibleSkills.get(0).getName().equals(currentSkillStateMachine.getName())) {</span>
<span class="fc" id="L653">			leaveCurrentSkillStateMachine();</span>
		}
<span class="fc" id="L655">		return possibleSkills.get(0);</span>

	}

	/**
	 * leaves the {@link #currentSkillStateMachine} and sets it as the
	 * {@link #lastUsedSkillStateMachine}
	 */
	private void leaveCurrentSkillStateMachine() {
<span class="fc bfc" id="L664" title="All 2 branches covered.">		if (this.currentSkillStateMachine != null) {</span>
<span class="fc" id="L665">			Logging.debug(&quot;Leaving the skill {}&quot;, this.currentSkillStateMachine.getName());</span>
		}
<span class="fc" id="L667">		this.lastUsedSkillStateMachine = this.currentSkillStateMachine;</span>
<span class="fc" id="L668">	}</span>

	/**
	 * Resets the {@link #currentSkillStateMachine} and removes all pending
	 * questions relating to the skill
	 * 
	 * @param alsoResetLastUsedSkillStateMachine if true, then also resets the
	 *                                           {@link #lastUsedSkillStateMachine}
	 *                                           and removes all pending questions
	 *                                           relating to that skill
	 */
	private void resetCurrentSkillStateMachine(boolean alsoResetLastUsedSkillStateMachine) {
<span class="fc bfc" id="L680" title="All 2 branches covered.">		if (this.currentSkillStateMachine == null) {</span>
<span class="fc" id="L681">			return;</span>
		}
<span class="fc" id="L683">		removeIntentsOfCurrentSkill();</span>
<span class="fc" id="L684">		this.currentSkillStateMachine.reset();</span>
<span class="fc" id="L685">		this.pendingSkillQuestions.removeAllSkillQuestions(this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L686">		this.wasLastQuestionSkillQuestion = false;</span>
<span class="fc" id="L687">		this.currentSkillStateMachine = this.lastUsedSkillStateMachine;</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">		if (alsoResetLastUsedSkillStateMachine) {</span>
<span class="fc" id="L689">			resetCurrentSkillStateMachine(false);</span>
		}
<span class="fc" id="L691">	}</span>

	/**
	 * Removes all {@link #pendingIntents} that the
	 * {@link #currentSkillStateMachine} can execute
	 */
	private void removeIntentsOfCurrentSkill() {
<span class="fc" id="L698">		Iterator&lt;String&gt; iterator = this.pendingIntents.iterator();</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">		while (iterator.hasNext()) {</span>
<span class="fc" id="L700">			String intent = iterator.next();</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">			if (this.currentSkillStateMachine.canExecute(intent)) {</span>
<span class="fc" id="L702">				iterator.remove();</span>
			}
<span class="fc" id="L704">		}</span>
<span class="fc" id="L705">	}</span>

	/**
	 * Checks weather the {@link #currentSkillStateMachine} has ended or not
	 * 
	 * @return true if the {@link #currentSkillStateMachine} has ended
	 */
	private boolean hasSkillStateMachineEnded() {
<span class="fc" id="L713">		boolean currentSkillStateMachineEnded = this.currentSkillStateMachine.hasEnded();</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">		if (currentSkillStateMachineEnded) {</span>
<span class="fc" id="L715">			Logging.debug(&quot;The Skill {} Ended&quot;, this.currentSkillStateMachine.getName());</span>
<span class="fc" id="L716">			resetCurrentSkillStateMachine(false);</span>
<span class="fc" id="L717">			this.currentSkillStateMachine = this.lastUsedSkillStateMachine;</span>
<span class="fc" id="L718">			this.lastUsedSkillStateMachine = null;</span>
		}

<span class="fc" id="L721">		return currentSkillStateMachineEnded;</span>
	}

	/**
	 * Logs that a method on this object was called after it has been shut down
	 */
	private void logIllegalAccess() {
<span class="fc" id="L728">		Logging.error(&quot;The ConversationsEngine was invoked after it has been shut down&quot;);</span>
<span class="fc" id="L729">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>